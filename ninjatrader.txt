# NinjaTrader Integration Plan (CurvesV2)

## Implementation Overview

This plan outlines the integration of NinjaTrader with CurvesV2, focusing on cleanly removing MinimalPythonService and ensuring proper API endpoint matching.

### Key Components

1. **Configuration Management**:
   - Enhanced `CurvesV2Config` class with separate ports for main server (3001) and signal server (3002)
   - Added typed endpoint accessors for each API endpoint
   - Created `ConfigManager` for centralized configuration access using singleton pattern

2. **API Integration**:
   - Removed all `MinimalPythonService` dependencies
   - Modified `CurvesV2Service` to match exact endpoint formats:
     - `/api/signals/{instrument}` - for retrieving pattern signals
     - `/api/realtime_bars/{instrument}` - for sending bar data
     - `/api/signals/{instrument}/trade_results` - for reporting trade results
     - `/api/bars/{instrument}` - for sending historical bars with timeframe tracking

3. **Data Models**:
   - Using strongly typed models for API communication:
     - `BarData` for sending price bars
     - `CurvesV2Response` for signal responses
     - `PatternMatch` for pattern information
     - `TradeResult` for reporting completed trades

4. **MicroStrategy Integration**:
   - Updated to use `CurvesV2Service` exclusively
   - Leveraged `ConfigManager` for consistent configuration access
   - Implemented proper conversion between pattern matches and legacy signal format

## Implementation Details

### ConfigManager Design
- Singleton implementation ensures consistent configuration across components
- Constants for default values (ports, endpoints)
- JSON serialization for persistence
- Configuration validation

### CurvesV2Service Methods
- `SendBarAsync` - Sends real-time bar data to CurvesV2
- `CheckSignalsAsync` - Retrieves pattern signals and updates static properties
- `SendTradeResultAsync` - Reports trade results for pattern performance tracking
- `SendHistoricalBarsAsync` - Sends historical bars with timeframe metadata for data stitching

### Historical Data Management
- Historical bar data includes min/max timeframe metadata
- Timestamps stored in both milliseconds and human-readable format
- Enables future stitching of overlapping timeframes
- Instrument files (e.g., ES.json) contain complete bar data with timeframe information

### Signal/Pattern Handling
- Signal strength values (bull/bear) for directional bias
- Pattern matches for specific entry/exit points
- Conversion to legacy Signal format for backward compatibility

## API Endpoints Used

1. **Signal Retrieval**:
   - Endpoint: `http://localhost:3002/api/signals/{instrument}`
   - Method: GET
   - Response: Bull/bear signal strength and pattern matches

2. **Bar Data Submission**:
   - Endpoint: `http://localhost:3002/api/realtime_bars/{instrument}`
   - Method: POST
   - Data: Timestamp, OHLCV data

3. **Trade Result Reporting**:
   - Endpoint: `http://localhost:3002/api/signals/{instrument}/trade_results`
   - Method: POST
   - Data: Pattern ID, entry/exit details, PnL

4. **Historical Bar Import**:
   - Endpoint: `http://localhost:3002/api/bars/{instrument}`
   - Method: POST
   - Data: Array of bars with OHLCV data
   - Response: Includes min/max timeframe for data stitching

## Testing Considerations

1. Verify connection to both servers (ports 3001 and 3002)
2. Test with sufficient historical data (30+ bars)
3. Verify signal detection and pattern matching
4. Test trade result reporting for completed trades
5. Verify configuration persistence
6. Validate historical data timeframe tracking

## Limitations & Requirements

1. Both servers must be running (main UI on 3001, signal on 3002)
2. Rate limiting prevents overwhelming servers
3. Pattern matching requires sufficient bar history
4. Error handling includes retry logic and graceful failure

This implementation provides a clean, maintainable integration with CurvesV2 that matches the exact API endpoints while removing legacy dependencies on MinimalPythonService.